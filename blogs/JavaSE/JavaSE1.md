---
title: JavaSE语法
date: 2021-05-19
sidebar: 'auto'
tags:
 - JavaSE
 - 面试题
categories: 
 - 学
publish: true
---

# JavaSE基础

## javaSE语法

### 一、Java 有没有 goto 语句？

goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。有 goto 和 const两个保留字，平常命名的时候尽量不一样。

### 二、& 和 && 的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。

&&之所以称为短路运算是因为，如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行 运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为 `username != null &&!username.equals("")`，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 `NullPointerException` 异常。

**注意：**逻辑或运算符（|） 和短路或运算符（||）的差别也是如此。

### 三、两对象值相同 (x.equals(y) == true) ，但却可有不同的 hashCode，这句 话对不对？

不对，如果两个对象 x 和 y 满足 `x.equals(y) == true`，它们的哈希码（hashCode）应当相同。

Java 对于 eqauls 方法和 hashCode 方法是这样规定的：**(1)**如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；**(2)**如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 **Set 集合**中，同时增加新元素的效率会大大下降（**对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降**）。

### 四、是否可以继承 String ？

String 类是 final 类，不可以被继承。

### 五、String，StringBuilder，StringBuffer的区别是啥？

1. 从可变性来讲String的是不可变的，StringBuilder，StringBuffer的长度是可变的。
2. 从运行速度上来讲StringBuilder > StringBuffer > String。
3. 从线程安全上来StringBuilder是线程不安全的，而StringBuffer是线程安全的（`synchronized` 进行同步）。

所以 String：适用于少量的字符串操作的情况，StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况，StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。

### 六、`synchronized`的表现形式

- 对于普通同步方法 ，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的class对象。
- 对于同步方法块，锁是Synchonized括号配置的对象。

### 七、`synchronized`的原理（扯远了）

**`synchronized`是一个重量级锁，实现依赖于`JVM` 的 `monitor` 监视器锁。**主要使用`monitorenter`和`monitorexit`指令来实现方法同步和代码块同步。在编译的是时候，会将`monitorexit`指令插入到同步代码块的开始位置，而`monitorexit`插入方法结束处和异常处，并且每一个`monitorexit`都有一个与之对应的`monitorexit`。

任何对象都有一个`monitor`与之关联，当一个`monitor`被持有后，它将被处于锁定状态，线程执行到`monitorenter`指令时间，会尝试获取对象所对应的`monitor`的所有权，即获取获得对象的锁，由于在编译期会将`monitorexit`插入到方法结束处和异常处，所以在方法执行完毕或者出现异常的情况会自动释放锁。

### 八、重载（overload）和重写（override）的区别？重载的方法能否根据返回类型 进行区分？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。**重载发生在一个类中**，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同或者二者都不同**）则视为重载；**重写发生在子类与父类之间**，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。**重载对返回类型没有特殊的要求。**

**方法重载的规则：**

1.  方法名一致，参数列表中参数的顺序，类型，个数不同。
2.  重载与方法的返回值无关，存在于父类和子类，同类中。
3.  可以抛出不同的异常，可以有不同修饰符。

**方法重写的规则：**

1. 参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。 
2. 构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次 声明。 
3. 访问权限不能比父类中被重写的方法的访问权限更低。 
4. 重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

### 九、为什么函数不能根据返回类型来区分重载？

因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。

```java
1．float max(int a, int b);
2．int max(int a, int b);
```

当调用 `max(1, 2);`时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。

### 十、char 型变量中能不能存储一个中文汉字，为什么？

可以。因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接 使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。

**补充：**使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被 从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字 符流和字节流之间进行转换的**转换流**，如 **InputStreamReader** 和 **OutputStreamReader**，这两个类是字节流和字符 流之间的适配器类，承担了编码转换的任务。

### 十一、抽象类(abstract class)和接口(interface)有什么异同？

**不同：**

***抽象类：***

- 抽象类中可以定义构造器 
- 可以有抽象方法和具体方法 
- 接口中的成员全都是 public 的 
- 抽象类中可以定义成员变量 
- 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法 
- 抽象类中可以包含静态方法
- 一个类只能继承一个抽象类

***接口：***

- 接口中不能定义构造器
- 方法全部都是抽象方法
- 抽象类中的成员可以是 private、默认、protected、public
- 接口中定义的成员变量实际上都是常量
- 接口中不能有静态方法
- 一个类可以实现多个接口

***相同：***

- 不能够实例化
- 可以将抽象类和接口类型作为引用类型
- 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要 被声明为抽象类

### 十二、抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法 (native)，是否可同时被 synchronized

**都不能。**

1. 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。
2. 本地方法是由 本地代码实现的方法，而抽象方法是没有实现的，也是矛盾的。
3. synchronized 和方法的实现细节有关， 抽象方法不涉及实现细节，因此也是相互矛盾的。

### 十三、静态变量和实例变量的区别？

**静态变量:** 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。

**实例变量:** 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。

### 十四、==和 equals 的区别？

equals 和== 最大的区别是**一个是方法一个是运算符**。

**==：**如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象 的地址值是否相等。

**equals()：**用来比较方法两个对象的内容是否相等。

**注意：**equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址。

### 十五、break 和 continue 的区别？

break 和 continue 都是用来控制循环的语句。 

break 用于完全结束一个循环，跳出循环体执行循环后面的语句。 

continue 用于跳过本次循环，执行下次循环。

### 十六、Java 中实现多态的机制是什么？

靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法**在运行期才动态绑定**，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。

